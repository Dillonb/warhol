
//CAUTION: The content of this file is automatically generated by Emacs orgmode
//from the file warhol.org that should either be in this, or the parent
//directory. Consequently, any modifications made to this file will likely be
//ephemeral. Please edit warhol.org instead.
////////////////////////////////////////////////////////////////////////////////
//
// warhol.cpp
//
////////////////////////////////////////////////////////////////////////////////
//
//================================================================================
// This file is part of project warhol, a simple demonstration of the OpenGL
// API, that draws 600 colorful translucent triangles, rectangles and ellipses
// on the display. Since the random number seed is initialized to Unix time,
// a different canvas is obtained with each execution.
//
// warhol is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// warhol is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with union-find.org.  If not, see <http://www.gnu.org/licenses/>.
//
// Copyright (C) 2014, 2015 Robert R. Snapp.
//================================================================================
// This file was automatically generated using an org-babel tangle operation with
// the file warhol.org. Thus, the latter file should be edited instead of
// this file.
//================================================================================
//
//
// Standard C++ libraries
#include <algorithm>   // for max and min
#include <iostream>
#include <stdexcept>
#include <cmath>
#include <climits>
#include <ctime>
#include <sstream>
#include <fstream>
#include <string>
#include <cstdlib>                       // for rand(), srand()
#include <random>
#include <vector>
#include <cstring>

// Graphics libraries that extend OpenGL
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

// FreeImage headers, for digital image format support.
#include <FreeImage.h>

struct Figure {
    GLuint model;
    glm::mat4 transformation;
    GLuint texture;
};

const GLuint N_MODELS = 4;
const GLuint N_Indices[N_MODELS] = {15, 29, 71, 79};     // number of indices per model;
GLuint VertexArrayObject[N_MODELS];              // One GPU object per model: initialized in init()
GLuint ElementBufferObject[N_MODELS];            // One Element Buffer Object per model: initialized in init();
GLuint TextureObject[3];                         // One texture for each WIF_mode (see warholImageFrame())
const GLuint N_COLORS = 36;                      // The number of colors in each random color palette
const GLuint N_FRAMES = 6;                       // The number of frames in each texture map
const int N_FIGURES = 3;
std::vector<Figure> Figs;

GLFWwindow* gWindow = NULL;               // pointer to the graphics window goverened by the OS
const glm::vec2 CANVAS(800, 800);         // Our window and viewport dimensions.

const size_t MAX_FILE_MATCH_ATTEMPTS = 1000;

GLuint VSL_theTexture; // vertex shader location for theTexture uniform variable;
GLuint VSL_theTransformation; // vertex shader location for the transformation uniform matrix

double Theta = M_PI/90.0f;
double Phi   = 0;
double Rho   = 8.0f;

GLuint loadAndCompileShader(GLenum shaderType, const std::string& path) {
    std::ifstream f;
    f.open(path.c_str(), std::ios::in | std::ios::binary);
    if (!f.is_open()) {
        throw std::runtime_error(std::string("Can't open shader file ") + path);
    }

    // read the shader program from the file into the buffer
    std::stringstream buffer;
    buffer << f.rdbuf();

    GLuint shader = glCreateShader(shaderType);
    if (! shader) {
        throw std::runtime_error(std::string("Can't create shader for file ") + path);
    }

    // tricky conversion from a stringstream buffer to a C (null terminated) string.
    const std::string& bufferAsString = buffer.str();
    const GLchar* shaderCode = bufferAsString.c_str();
    const GLchar* codeArray[] = { shaderCode };
    GLint size = strlen(shaderCode);
    glShaderSource(shader, 1, codeArray, NULL);
    glCompileShader(shader);

    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
    if (! status) {
        std::cerr << "Compilation error in shader file " << path << std::endl;
        GLint logLen;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logLen);
        if (logLen > 0) {
            char *log = new char[logLen];
            GLsizei written;
            glGetShaderInfoLog(shader, logLen, &written, log);
            std::cerr << "Shader log: " << std::endl;
            std::cerr << log << std::endl;
            delete [] log;
        }
        throw std::runtime_error(
                std::string("Can't compile the shader defined in file ") + path);
    }
    return shader;
}

GLuint createVertexFragmentProgram(const std::string& vertex_shader_path, const std::string& fragment_shader_path) {
    GLuint vertexShader   = loadAndCompileShader(GL_VERTEX_SHADER,   vertex_shader_path);
    GLuint fragmentShader = loadAndCompileShader(GL_FRAGMENT_SHADER, fragment_shader_path);

    GLuint program = glCreateProgram();
    if (! program) {
        throw std::runtime_error("Can't create GLSL program.");
    }

    glAttachShader(program, vertexShader);
    glAttachShader(program, fragmentShader);
    glLinkProgram(program);

    GLint status;
    glGetProgramiv(program, GL_LINK_STATUS, &status);
    if (! status) {
        std::cerr << "Linking error in shader program!" << std::endl;
        GLint logLen;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLen);
        if (logLen > 0) {
            char *log = new char[logLen];
            GLsizei written;
            glGetProgramInfoLog(program, logLen, &written, log);
            std::cerr << "Shader log: " << std::endl;
            std::cerr << log << std::endl;
            delete [] log;
        }
        throw std::runtime_error("Can't link shader program.");
    }
    return program;
}

std::string getUnusedFileName(const std::string &prefix, const std::string &ext) {
    std::string imageFileName("");  // initial value is returned in search fails.

    // load the current date and time in theTime.
    time_t theTime;
    time(&theTime);

    // convert the date time into the current locale.
    struct tm *theTimeInfo;
    theTimeInfo = localtime(&theTime);

    // represent the date and time in the format "150117184509" for 2015 January 17,
    // 18 hours, 45 minutes, 09 seconds.
    const int TIME_STRING_SIZE = 16;  // must be at least 13.
    char timeString[TIME_STRING_SIZE];
    strftime(timeString, TIME_STRING_SIZE, "%y%m%d%H%M%S", theTimeInfo);

    std::stringstream filename;
    std::ifstream fs;
    int index =0;

    // find a new filename of the form <filenameprefix>_<timeString>_<index>.<ext>, where
    // <index> is incremented as needed.
    do {
        // reset the stringstream filename
        filename.str(std::string());      // clear the buffer content
        filename.clear();                 // reset the state flags

        // propose an available (unused) filename.
        filename << prefix << "_" << timeString << "_" << index++ << ext;

        // Ensure the ifstream fs is closed.
        if (fs.is_open()) fs.close();

        // If file does not exist, it can't be opened in input mode.
        fs.open(filename.str(), std::ios_base::in);
    } while (fs.is_open() && index < MAX_FILE_MATCH_ATTEMPTS);

    // Test to see if a unique name was actually found.
    if (fs.is_open() && index >= MAX_FILE_MATCH_ATTEMPTS) {
        fs.close();  // failure: there are too many files with the same time stamp.
    } else {       // N.B. fs must be closed on this branch, right?
        imageFileName = filename.str();  // success!
    }
    return imageFileName;
}

GLubyte* importImage(const std::string &path, int *width, int *height) {
    GLubyte* pixels;  // The raw pixel array that will contain the read image.
    int fif_load_option = 0;

    // The following snippet is based on the "Generic image loader example provided in the
    // FreeImage 3.16.0 documentation, page 24 (Appendix).

    FREE_IMAGE_FORMAT fif = FIF_UNKNOWN;
    fif = FreeImage_GetFileType(path.c_str(), 0);
    if (fif == FIF_UNKNOWN) {
        // try to guess the file format from the file extension.
        fif = FreeImage_GetFIFFromFilename(path.c_str());
    }
    if (fif == FIF_UNKNOWN) {
        // Give up. Bad input.
        throw std::runtime_error(std::string("Can't infer the image file format of file: ") + path);
    }

    // fif is known, is a readable image format?
    if (! FreeImage_FIFSupportsReading(fif)) {
        throw std::runtime_error(std::string("File image format is not readable for file: ") + path);
    }

    // fif is known and readable. Note that FreeImage_Load supports an optional third argument which we
    // here ignore.

    if (fif == FIF_JPEG) {
        fif_load_option = JPEG_EXIFROTATE;
    }

    FIBITMAP *bitmap = FreeImage_Load(fif, path.c_str(), fif_load_option);
    if (! bitmap) {
        throw std::runtime_error(std::string("Can't create bitmap from file ") + path);
    }

    *width = FreeImage_GetWidth(bitmap);
    *height = FreeImage_GetHeight(bitmap);
    int bytes_per_line = FreeImage_GetLine(bitmap);    // line width in bytes

    // Some diagnostic information
    std::cout << "Found and read file " << path << "(" << *width << "*" << *height << ")" << std::endl;
    std::cout << "Number of bits per pixel = " << FreeImage_GetBPP(bitmap) << std::endl;
    std::cout << "Line width in bytes = " << bytes_per_line << std::endl;
    std::cout << "Pitch (width rounded to next 32 bit boundary) = " << FreeImage_GetPitch(bitmap) << std::endl;
    std::cout << "Red   mask = " << FreeImage_GetRedMask(bitmap)   << std::endl;
    std::cout << "Green mask = " << FreeImage_GetGreenMask(bitmap) << std::endl;
    std::cout << "Blue  mask = " << FreeImage_GetBlueMask(bitmap)  << std::endl;

    pixels = new GLubyte [*height * bytes_per_line];
    if (! pixels) {
        std::runtime_error(std::string("Can't allocate raw pixel array."));
    }

    const unsigned int red_mask   = 0xFF0000;
    const unsigned int green_mask = 0x00FF00;
    const unsigned int blue_mask  = 0x0000FF;
    const int bits_per_pixel     = 24;

    FreeImage_ConvertToRawBits(pixels, bitmap, bytes_per_line, bits_per_pixel, red_mask, green_mask, blue_mask, FALSE);
    FreeImage_Unload(bitmap);
    return pixels;
}

enum class WIF_Mode: int {copy=0, natural, wild};

GLubyte* warholImageFrame(const GLubyte* image, int npixels, int ncolors, int nframes, WIF_Mode mode) {
    GLubyte* clone = new GLubyte[3*npixels*nframes];                                       // output raster
    GLubyte* natural_palette;
    GLubyte* wild_palette;
    GLubyte *output_palette;                             // a pointer to either natural_palette or wild_palette

    int image_size = 3*npixels;

    if (mode == WIF_Mode::copy) {
        for(int frame = 0; frame < nframes; frame++) {
            int frame_offset = image_size*frame;
            for (int i = 0; i < image_size; i++) {
                clone[frame_offset + i] = image[i];
            }
        }

    } else {                                                // for WIF_Mode::natural or WIF_Mode::wild
        natural_palette = new GLubyte[3*ncolors];
        if (mode == WIF_Mode::natural) {
            output_palette = natural_palette;
        } else {                                            // mode == WIF_Mode::wild
            wild_palette = new GLubyte[3*ncolors];
            output_palette = wild_palette;
        }

        // Here we demonstrate the Mersenne Twister random number generator that is part of C++
        // You need to include <random> to import the declarations.
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dist(0,255);

        for (int frame = 0; frame < nframes; frame++) {
            int frame_offset = image_size*frame;

            // each frame receives new color palettes
            for (int i = 0; i < 3*ncolors; i++) {
                natural_palette[i]  = static_cast<GLubyte>(dist(gen));  // A random byte generated from the uniform distribution
            }

            if (mode == WIF_Mode::wild) {
                for (int i = 0; i < 3*ncolors; i++) {
                    wild_palette[i] = static_cast<GLubyte>(dist(gen));
                }
            }

            for (int i = 0; i < npixels; i++) {
                int image_offset = 3*i;
                double min_distance = HUGE_VAL;   // defined in <cmath>
                int nearest_natural_color = 0;

                for (int j = 0; j < ncolors; j++) {
                    unsigned long distance = 0;
                    int color_offset = 3*j;
                    for (int k = 0; k < 3; k++) {
                        double diff = image[image_offset + k] - natural_palette[color_offset + k];
                        distance += diff*diff;
                    }
                    if (distance < min_distance) {
                        min_distance = distance;
                        nearest_natural_color = color_offset;
                    }
                }

                for (int k = 0; k < 3; k++) {
                    clone[frame_offset + image_offset + k] = output_palette[nearest_natural_color + k];
                }
            }
        }

        delete [] natural_palette;
        if (mode == WIF_Mode::wild) {
            delete [] wild_palette;
        }
    }

    return clone;
}

void exportImageAsPNG(GLubyte* image, GLuint width, GLuint height, const std::string& filename_prefix) {
    // The following variables are introduced to clarify the call signature of
    // FreeImage_ConvertFromRawBits, which will convert the GLubyte pixel buffer
    // into a FreeImage buffer.
    const unsigned int red_mask             = 0xFF0000;
    const unsigned int green_mask           = 0x00FF00;
    const unsigned int blue_mask            = 0x0000FF;
    const unsigned int bits_per_pixel       = 24;
    const bool top_left_pixel_appears_first = false;

    unsigned int bytes_per_row = 3 * width;

    FIBITMAP* fi_image = FreeImage_ConvertFromRawBits(image, width, height, bytes_per_row,
            bits_per_pixel, red_mask, green_mask,
            blue_mask, top_left_pixel_appears_first);

    std::string imagefilename = getUnusedFileName(filename_prefix, std::string(".png"));
    if (imagefilename.length() == 0) {
        throw std::runtime_error("Can't find an available png file name.");
    }

    FreeImage_Save(FIF_PNG, fi_image, imagefilename.c_str(), 0);  // Save fi_image as a PNG file.

    // Free allocated memory
    FreeImage_Unload(fi_image);
    return;
}

void exportWindowAsPNG(GLFWwindow* window, const std::string &prefix) {
    // Recover window dimensions from glfw
    int width;
    int height;
    glfwGetFramebufferSize(window, &width, &height);

    // allocate a buffer to store all of the pixels in the frame buffer.
    GLubyte* pixels = new GLubyte [width * height * sizeof(GLubyte)* 3];
    if (! pixels) {
        throw std::runtime_error(std::string("Can't allocate pixel array for image of size ")
                + std::to_string(width) + std::string(" by ") + std::to_string(height)
                + std::string(" pixels."));
    }

    glPixelStorei(GL_PACK_ALIGNMENT, 1); // Align data by bytes so the framebuffer data will fit.
    glReadBuffer(GL_FRONT);              // The front color buffer is the visible one.
    glReadPixels(0, 0, width, height, GL_BGR, GL_UNSIGNED_BYTE, pixels);

    exportImageAsPNG(pixels, width, height, prefix);

    delete [] pixels;
    return;
}

glm::mat4 getTransformation(GLfloat sx, GLfloat sy, GLfloat theta, GLfloat tx, GLfloat ty) {
    glm::mat4 identity_mtx = glm::mat4(1.0f);
    glm::mat4 translate_mtx = glm::translate(identity_mtx, glm::vec3(tx, ty, 0.0f));
    glm::mat4 translate_rotate_mtx = glm::rotate(translate_mtx, theta, glm::vec3(0.0f, 0.0f, 1.0f));
    glm::mat4 translate_rotate_scale_mtx = glm::scale(translate_rotate_mtx, glm::vec3(sx, sy, 1.0f));
    return translate_rotate_scale_mtx;
}

glm::mat4 getRandomTransformation() {
    GLfloat sx    = 0.10*static_cast<GLfloat>(rand())/RAND_MAX + 0.05f;
    GLfloat sy    = 0.10*static_cast<GLfloat>(rand())/RAND_MAX + 0.05f;
    GLfloat theta = 2.0*M_PI*static_cast<GLfloat>(rand())/RAND_MAX;
    GLfloat tx    = 2.0*static_cast<GLfloat>(rand())/RAND_MAX - 1.0;
    GLfloat ty    = 2.0*static_cast<GLfloat>(rand())/RAND_MAX - 1.0;

    return getTransformation(sx, sy, theta, tx, ty);
}

glm::vec4 getRandomColor() {
    GLfloat red   = static_cast<GLfloat>(rand())/RAND_MAX;
    GLfloat green = static_cast<GLfloat>(rand())/RAND_MAX;
    GLfloat blue  = static_cast<GLfloat>(rand())/RAND_MAX;
    GLfloat alpha = 0.75*static_cast<GLfloat>(rand())/RAND_MAX + 0.25;  // not too transparent.
    return glm::vec4(red, green, blue, alpha);
}


void init(int argc, char** argv) {
    int width  = 0;
    int height = 0;

    srand(time(NULL));  // initialize the random number generator rand(), using the time as a seed.

    if (argc == 2) {
        char* path = argv[1];
        GLubyte *pixels = importImage(std::string(path), &width, &height);
        if (! pixels) {
            throw std::runtime_error(std::string("Can't load image file ") + path);
        }
        int npixels = width*height;
        glGenTextures(3, &TextureObject[0]);


        for (int i = 0; i < 3; i++) {
            GLubyte *clone = warholImageFrame(pixels, npixels, N_COLORS, 6, static_cast<WIF_Mode>(i));
            exportImageAsPNG(clone, width, N_FRAMES*height, std::string("warhol_texture"));

            glActiveTexture(GL_TEXTURE0 + i);
            glBindTexture(GL_TEXTURE_2D, TextureObject[i]);
            glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGB8, static_cast<GLsizei>(width), static_cast<GLsizei>(6*height));
            glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, static_cast<GLsizei>(width), static_cast<GLsizei>(6*height), GL_RGB, GL_UNSIGNED_BYTE, clone);

            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            delete [] clone;
        }
        delete [] pixels;
    } else {
        std::cerr << "Usage: " << argv[0] << " <image-file-name>" << std::endl;
        exit(1);
    }

    const GLfloat h = 0.5f;
    GLfloat cube_positions[][3] = {
        {-h, -h, +h}, {+h, -h, +h}, {+h, +h, +h}, {-h, +h, +h}, // top    (z = +h)
        {+h, -h, -h}, {-h, -h, -h}, {-h, +h, -h}, {+h, +h, -h}, // bottom (z = -h)
        {-h, -h, -h}, {+h, -h, -h}, {+h, -h, +h}, {-h, -h, +h}, // back   (y = -h)
        {+h, +h, -h}, {-h, +h, -h}, {-h, +h, +h}, {+h, +h, +h}, // front  (y = +h)
        {+h, -h, -h}, {+h, +h, -h}, {+h, +h, +h}, {+h, -h, +h}, // right  (x = +h)
        {-h, +h, -h}, {-h, -h, -h}, {-h, -h, +h}, {-h, +h, +h}  // left   (x = -h)
    };


    GLfloat cube_texture_coordinates[][2] = {
        {0.0f, 0.0f},      {1.0f, 0.0f},      {1.0f, 1.0f/6.0f}, {0.0f, 1.0f/6.0f},
        {0.0f, 1.0f/6.0f}, {1.0f, 1.0f/6.0f}, {1.0f, 1.0f/3.0f}, {0.0f, 1.0f/3.0f},
        {0.0f, 1.0f/3.0f}, {1.0f, 1.0f/3.0f}, {1.0f, 1.0f/2.0f}, {0.0f, 1.0f/2.0f},
        {0.0f, 1.0f/2.0f}, {1.0f, 1.0f/2.0f}, {1.0f, 2.0f/3.0f}, {0.0f, 2.0f/3.0f},
        {0.0f, 2.0f/3.0f}, {1.0f, 2.0f/3.0f}, {1.0f, 5.0f/6.0f}, {0.0f, 5.0f/6.0f},
        {0.0f, 5.0f/6.0f}, {1.0f, 5.0f/6.0f}, {1.0f, 1.0f},      {0.0f, 1.0f}
    };

    GLfloat tetrahedron_positions[][3] = {
        { -h, -h, -h },  // Southeast facing
        {  h,  h, -h },
        {  h, -h,  h },
        { -h, -h, -h },  // Northwest facing
        {  h,  h, -h },
        { -h,  h,  h },
        { -h,  h,  h }, // Northeast facing
        {  h, -h,  h },
        {  h,  h, -h },
        { -h,  h,  h }, // Southwest facing
        {  h, -h,  h },
        { -h, -h, -h }
    };

    const GLfloat g = 1.61803398875f; // Golden ratio
    const GLfloat f = 1.0f;
    const GLfloat j = 0.61803398875f; // 1 / golden ratio

    GLfloat dodecahedron_positions[][3] {
        // {+-1.0, +-1.0, +-1.0}
        {-f, -f, -f}, // 0
        {-f, -f, +f}, // 1
        {-f, +f, -f}, // 2
        {-f, +f, +f}, // 3
        {+f, -f, -f}, // 4
        {+f, -f, +f}, // 5
        {+f, +f, -f}, // 6
        {+f, +f, +f}, // 7

        // {0, +-j, +-g}
        { 0, -j, -g}, // 8
        { 0, -j, +g}, // 9
        { 0, +j, -g}, // 10
        { 0, +j, +g}, // 11

        // {+-j, +-g, 0}
        {-j, -g,  0}, // 12
        {-j, +g,  0}, // 13
        {+j, -g,  0}, // 14
        {+j, +g,  0}, // 15

        // {+-g, 0, +-j}
        {-g,  0, -j}, // 16
        {-g,  0, +j}, // 17
        {+g,  0, -j}, // 18
        {+g,  0, +j}  // 19
    };


    GLushort dodecahedron_indices[] = {
        // Faces surrounding 0
        0, 8, 16, 10, 2, 0xFFFF,
        0, 8, 12, 4, 14, 0xFFFF,
        0, 12, 16, 1, 17, 0xFFFF,

        // Faces surrounding 1
        1, 12, 9, 14, 5, 0xFFFF,
        1, 9, 17, 11, 3, 0xFFFF,

        // Faces surrounding 2
        2, 10, 13, 6, 15, 0xFFFF,
        2, 16, 13, 17, 3, 0xFFFF,

        // Faces surrounding 3
        3, 11, 13, 7, 15, 0xFFFF,

        // Faces surrounding 4
        4, 8, 18, 10, 6, 0xFFFF,
        4, 18, 14, 19, 5, 0xFFFF,

        // Faces surrounding 5
        5, 19, 9, 7, 11, 0xFFFF,

        // Faces surrounding 6
        6, 15, 18, 7, 19};


    GLfloat icosahedron_positions[][3] = {
        {-1.0f, 0.0f, +g},  // 0
        {+1.0f, 0.0f, +g},  // 1
        {0.0f, +g, +1.0f},  // 2
        {0.0f, -g, +1.0f},  // 3
        {+g, -1.0f, 0.0f},  // 4
        {0.0f, -g, -1.0f},  // 5
        {+1.0f, 0.0f, -g},  // 6
        {+g, +1.0f, 0.0f},  // 7
        {0.0f, +g, -1.0f},  // 8
        {-1.0f, 0.0f, -g},  // 9
        {-g, -1.0f, 0.0f},  // 10
        {-g, +1.0f, 0.0f}
    };  // 11

    GLushort icosahedron_indices[] = {
        0,  1,  2, 0xFFFF,
        0,  1,  3, 0xFFFF,
        1,  3,  4, 0xFFFF,
        3,  4,  5, 0xFFFF,
        4,  5,  6, 0xFFFF,
        4,  6,  7, 0xFFFF,
        6,  7,  8, 0xFFFF,
        1,  4,  7, 0xFFFF,
        1,  2,  7, 0xFFFF,
        2,  7,  8, 0xFFFF,
        5,  6,  9, 0xFFFF,
        6,  8,  9, 0xFFFF,
        3,  4, 10, 0xFFFF,
        5,  9, 10, 0xFFFF,
        0,  3, 10, 0xFFFF,
        0, 10, 11, 0xFFFF,
        9, 10, 11, 0xFFFF,
        8,  9, 11, 0xFFFF,
        8,  2, 11, 0xFFFF,
        1,  2, 11};


    GLfloat dodecahedron_texture_coordinates[][2] = {
        {0.0f, 0.0f},      {1.0f, 0.0f},      {1.0f, 1.0f/6.0f}, {0.0f, 1.0f/6.0f},
        {0.0f, 1.0f/6.0f}, {1.0f, 1.0f/6.0f}, {1.0f, 1.0f/3.0f}, {0.0f, 1.0f/3.0f},
        {0.0f, 1.0f/3.0f}, {1.0f, 1.0f/3.0f}, {1.0f, 1.0f/2.0f}, {0.0f, 1.0f/2.0f},
        {0.0f, 1.0f/2.0f}, {1.0f, 1.0f/2.0f}, {1.0f, 2.0f/3.0f}, {0.0f, 2.0f/3.0f},
        {0.0f, 2.0f/3.0f}, {1.0f, 2.0f/3.0f}, {1.0f, 5.0f/6.0f}, {0.0f, 5.0f/6.0f},
        {0.0f, 5.0f/6.0f}, {1.0f, 5.0f/6.0f}, {1.0f, 1.0f},      {0.0f, 1.0f}
    };

    GLfloat icosahedron_texture_coordinates[][2] = {
        {0.0f, 0.0f},      {1.0f, 0.0f},      {1.0f, 1.0f/6.0f}, {0.0f, 1.0f/6.0f},
        {0.0f, 1.0f/6.0f}, {1.0f, 1.0f/6.0f}, {1.0f, 1.0f/3.0f}, {0.0f, 1.0f/3.0f},
        {0.0f, 1.0f/3.0f}, {1.0f, 1.0f/3.0f}, {1.0f, 1.0f/2.0f}, {0.0f, 1.0f/2.0f},
        {0.0f, 1.0f/2.0f}, {1.0f, 1.0f/2.0f}, {1.0f, 2.0f/3.0f}, {0.0f, 2.0f/3.0f},
        {0.0f, 2.0f/3.0f}, {1.0f, 2.0f/3.0f}, {1.0f, 5.0f/6.0f}, {0.0f, 5.0f/6.0f},
        {0.0f, 5.0f/6.0f}, {1.0f, 5.0f/6.0f}, {1.0f, 1.0f},      {0.0f, 1.0f}
    };
    const GLfloat HALF_SQRT_3 = 0.8660250378444f;
    GLfloat tetrahedron_texture_coordinates[][2] = {
        {0.0f, 0.0f},    {1.0f, 0.0f},    {0.5f, HALF_SQRT_3/6.0f},
        {0.0f, HALF_SQRT_3/6.0f}, {1.0f, HALF_SQRT_3/6.0f}, {0.5f, HALF_SQRT_3/3.0f},
        {0.0f, HALF_SQRT_3/3.0f}, {1.0f, HALF_SQRT_3/3.0f}, {0.5f, HALF_SQRT_3/2.0f},
        {0.0f, HALF_SQRT_3/2.0f}, {1.0f, HALF_SQRT_3/2.0f}, {0.5f, HALF_SQRT_3/1.5f},
    };

    GLushort cube_indices[] = {
        0,  3,  1,  2, 0xFFFF,
        4,  7,  5,  6, 0xFFFF,
        8, 11,  9, 10, 0xFFFF,
        12, 15, 13, 14, 0xFFFF,
        16, 19, 17, 18, 0xFFFF,
        20, 23, 21, 22};

    GLushort tetrahedron_indices[] = {
        0,  1,  2, 0xFFFF,
        3,  4,  5, 0xFFFF,
        6,  7,  8, 0xFFFF,
        9, 10, 11};

    // Tetrahedron
    glGenBuffers(N_MODELS, ElementBufferObject);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ElementBufferObject[0]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,
            sizeof(tetrahedron_indices), tetrahedron_indices, GL_STATIC_DRAW);

    // Cube
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ElementBufferObject[1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,
            sizeof(cube_indices), cube_indices, GL_STATIC_DRAW);

    // Dodecahedron
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ElementBufferObject[2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,
            sizeof(dodecahedron_indices), dodecahedron_indices, GL_STATIC_DRAW);

    // Icosahedron
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ElementBufferObject[3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,
            sizeof(icosahedron_indices), icosahedron_indices, GL_STATIC_DRAW);

    glGenVertexArrays(N_MODELS, VertexArrayObject);

    GLuint vboHandles[N_MODELS];
    glGenBuffers(N_MODELS, vboHandles);

    GLuint tetrahedron_buffer  = vboHandles[0];
    GLuint cube_buffer         = vboHandles[1];
    GLuint dodecahedron_buffer = vboHandles[2];
    GLuint icosahedron_buffer  = vboHandles[3];

    // Tetrahedron
    glBindVertexArray(VertexArrayObject[0]);

    glBindBuffer(GL_ARRAY_BUFFER, tetrahedron_buffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(tetrahedron_positions) + sizeof(tetrahedron_texture_coordinates), NULL, GL_STATIC_DRAW);
    glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(tetrahedron_positions), tetrahedron_positions);
    glBufferSubData(GL_ARRAY_BUFFER, sizeof(tetrahedron_positions), sizeof(tetrahedron_texture_coordinates), tetrahedron_texture_coordinates);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL);   // vertices at location 0
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0,          // texture coordinates at location 1
            (const GLvoid *) sizeof(tetrahedron_positions));

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);
    glEnableVertexAttribArray(3);

    // Cube
    glBindVertexArray(VertexArrayObject[1]);

    glBindBuffer(GL_ARRAY_BUFFER, cube_buffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(cube_positions) + sizeof(cube_texture_coordinates), NULL, GL_STATIC_DRAW);
    glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(cube_positions), cube_positions);
    glBufferSubData(GL_ARRAY_BUFFER, sizeof(cube_positions), sizeof(cube_texture_coordinates), cube_texture_coordinates);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL);   // vertices at location 0
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0,          // texture coordinates at location 1
            (const GLvoid *) sizeof(cube_positions));

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);
    glEnableVertexAttribArray(3);


    // Dodecahedron
    glBindVertexArray(VertexArrayObject[2]);

    glBindBuffer(GL_ARRAY_BUFFER, dodecahedron_buffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(dodecahedron_positions) + sizeof(dodecahedron_texture_coordinates), NULL, GL_STATIC_DRAW);
    glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(dodecahedron_positions), dodecahedron_positions);
    glBufferSubData(GL_ARRAY_BUFFER, sizeof(dodecahedron_positions), sizeof(dodecahedron_texture_coordinates), dodecahedron_texture_coordinates);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL); // vertices at location 0
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0,
            (const GLvoid *) sizeof(dodecahedron_positions));

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);
    glEnableVertexAttribArray(3);


    // Isocahedron
    glBindVertexArray(VertexArrayObject[3]);

    glBindBuffer(GL_ARRAY_BUFFER, icosahedron_buffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(icosahedron_positions) + sizeof(icosahedron_texture_coordinates), NULL, GL_STATIC_DRAW);
    glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(icosahedron_positions), icosahedron_positions);
    glBufferSubData(GL_ARRAY_BUFFER, sizeof(icosahedron_positions), sizeof(icosahedron_texture_coordinates), icosahedron_texture_coordinates);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL); // vertices at location 0
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0,
            (const GLvoid *) sizeof(icosahedron_positions));

    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);
    glEnableVertexAttribArray(3);

    int modelSwapper = 0;

    for (int i = 0; i < 3; i++) {
        GLfloat tx = 3.0f*(i - 1);
        for(int j = 0; j < 3; j++) {
            GLfloat ty = 3.0*(j - 1);
            for(int k = 0; k < 3; k++) {
                GLfloat tz = 3.0*(k - 1);
                Figure fig;
                fig.model = modelSwapper;
                fig.transformation = glm::translate(glm::mat4(1.0f), glm::vec3(tx, ty, tz));
                //fig.texture = rand() % 3;
                Figs.push_back(fig);

                modelSwapper = (modelSwapper + 1) % N_MODELS;
            }
        }
    }



    GLuint shader_program = createVertexFragmentProgram(std::string("texture.vert"),
            std::string("texture.frag"));
    glUseProgram(shader_program);
    VSL_theTexture        = glGetUniformLocation(shader_program, "theTexture");
    VSL_theTransformation = glGetUniformLocation(shader_program, "theTransformation");
}
//------------------------------------------------------------------------------
//
// display() should be called whenever the canvas needs to be refreshed. Here it
// redraws the content of the Figs vector,

void display(void) {
    glClearColor(0.25,0.25,0.25,1); // gray
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_PRIMITIVE_RESTART);
    glPrimitiveRestartIndex(0xFFFF);

    glm::vec3 eye = glm::vec3(
            static_cast<GLfloat>(Rho*std::cos(Phi)*std::sin(Theta)),
            static_cast<GLfloat>(Rho*std::sin(Phi)*std::sin(Theta)),
            static_cast<GLfloat>(Rho*std::cos(Theta)));
    glm::vec3 ctr = glm::vec3(0.0f, 0.0f, 0.0f);
    glm::vec3 up  = glm::vec3(0.0f, 0.0f, 1.0f);
    glm::mat4 vmtx = glm::lookAt(eye, ctr, up);
    glm::mat4 pmtx = glm::perspective(glm::radians(50.0f), CANVAS.x/CANVAS.y, 0.1f, 10.0f);


    for (std::vector<Figure>::iterator iter = Figs.begin(); iter != Figs.end(); iter++) {
        glm::mat4 trans =  pmtx * vmtx * iter->transformation;
        glUniformMatrix4fv(VSL_theTransformation, 1, GL_FALSE, &trans[0][0]);
        glUniform1i(VSL_theTexture, iter->texture);
        glBindVertexArray(VertexArrayObject[iter->model]);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ElementBufferObject[iter->model]);

        glDrawElements(GL_TRIANGLE_STRIP, N_Indices[iter->model], GL_UNSIGNED_SHORT, NULL);
    }

    glfwSwapBuffers(gWindow);
}

void keyboard(GLFWwindow* window, int keyCode, int scanCode, int action, int modifiers) {
    switch (keyCode) {
        case GLFW_KEY_F:  // figure
            if (action == GLFW_PRESS && modifiers == 0x0000) {
                for (std::vector<Figure>::iterator iter = Figs.begin(); iter != Figs.end(); ++iter) {
                    iter->model = (iter->model + 1) % N_MODELS;
                    std::cout << "Figure = " << iter->model << std::endl;
                }
            }
            break;

        case GLFW_KEY_E: // east
            if (action == GLFW_PRESS) {
                if (modifiers == 0x0000) {
                    Phi += M_PI/90.0f;
                } else {
                    Phi += M_PI/9.0f;
                }
                std::cout << "Phi = " << Phi << std::endl;
            }
            break;
        case GLFW_KEY_H: // home
            if (action == GLFW_PRESS && modifiers == 0x0000) {
                Theta = M_PI/2.0f;
                Phi   = 0.0f;
                Rho   = 1.0f;
                std::cout << "Setting (Rho, Theta, Phi) = (" << Rho << ", " << Theta << ", " << Phi << ")" << std::endl;
            }
            break;
        case GLFW_KEY_N: // north
            if (action == GLFW_PRESS) {
                if (modifiers == 0x0000) {
                    Theta -= M_PI/90.0f;
                } else {
                    Theta -= M_PI/9.0f;
                }
                Theta = std::max(M_PI/180.0f, Theta);
                std::cout << "Theta = " << Theta << std::endl;
            }
            break;
        case GLFW_KEY_P: // print
            if (action == GLFW_PRESS && modifiers == 0x0000) {
                std::cout << "Pressed a lower-case p, scanCode = " << scanCode << std::endl;
                exportWindowAsPNG(window, std::string("warhol"));
            }
            break;
        case GLFW_KEY_Q: // quit
            if (action == GLFW_PRESS && modifiers == 0x0000) {
                std::cout << "Pressed a lower-case q, scanCode = " << scanCode << std::endl;
                glfwSetWindowShouldClose(window, GL_TRUE);
            }
            break;
        case GLFW_KEY_R:  // rho
            if (action == GLFW_PRESS) {
                if (modifiers == 0x0000) {
                    Rho += 0.2f;
                } else {
                    Rho -= 0.2f;
                }
                Rho = std::max(0.1, std::min(10.0, Rho));
                std::cout << "Rho = " << Rho << std::endl;
            }
            break;
        case GLFW_KEY_S:  // south
            if (action == GLFW_PRESS) {
                if (modifiers == 0x0000) {
                    Theta += M_PI/90.0f;
                } else {
                    Theta += M_PI/9.0f;
                }
                Theta = std::min(M_PI*89.0f/90.0f, Theta);
                std::cout << "Theta = " << Theta << std::endl;
            }
            break;
        case GLFW_KEY_W:  // west
            if (action == GLFW_PRESS) {
                if (modifiers == 0x0000) {
                    Phi -= M_PI/90.0f;
                } else {
                    Phi -= M_PI/9.0f;
                }
                std::cout << "Phi = " << Phi << std::endl;
            }
            break;
    }
    return;
}

//------------------------------------------------------------------------------
//
// error_callback is used by GLFW.

void GLFW_error_callback(int errorCode, const char* msg) {
    throw std::runtime_error(msg);
}

//------------------------------------------------------------------------------
//
// free image error callback
void fi_error_callback(FREE_IMAGE_FORMAT fif, const char* msg) {
    if (fif != FIF_UNKNOWN) {
        std:: cerr << FreeImage_GetFormatFromFIF(fif) << " format." << std:: endl;
    }
    throw std::runtime_error(msg);
}

int main(int argc, char** argv) {

    // initialize GLFW
    glfwSetErrorCallback(GLFW_error_callback);
    if (!glfwInit())
        throw std::runtime_error("glfwInit failed!");

    // Create the main window
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);

    int glfw_major;
    int glfw_minor;
    int glfw_rev;
    glfwGetVersion(&glfw_major, &glfw_minor, &glfw_rev);
    std::cout << "GLFW version: " << glfw_major << "." << glfw_minor << "." << glfw_rev << std::endl;

    gWindow = glfwCreateWindow((int) CANVAS.x, (int) CANVAS.y, argv[0], NULL, NULL);
    if (! gWindow)
        throw std::runtime_error("Can't create a glfw window!");

    glfwMakeContextCurrent(gWindow);

    glfwSetKeyCallback(gWindow, keyboard);
    glewExperimental = GL_TRUE;  // Prevents a segmentation fault on Mac OSX
    if (glewInit() != GLEW_OK)
        throw std::runtime_error("Can't initialize glewInit!");

    std::cout << "OpenGL version: "  << glGetString(GL_VERSION) << std::endl;
    std::cout << "GLSL version: "    << glGetString(GL_SHADING_LANGUAGE_VERSION) << std::endl;
    std::cout << "Vendor: "          << glGetString(GL_VENDOR) << std::endl;
    std::cout << "Graphics engine: " << glGetString(GL_RENDERER) << std::endl;

    if (! GLEW_VERSION_3_2)
        throw std::runtime_error("OpenGL 3.2 is not supported!");

    // Initializing FreeImage:
    FreeImage_Initialise(TRUE);                   // only load local plugins.
    FreeImage_SetOutputMessage(fi_error_callback);

    // Let's see the version of FreeImage:
    std::cout << "FreeImage version = " << FreeImage_GetVersion() << std::endl;

    init(argc, argv); // Initialize the model.

    int update_count = 0;
    while(! glfwWindowShouldClose(gWindow)) {
        update_count++;
        display();
        glfwWaitEvents();     // or, replace with glfwPollEvents();
    }

    FreeImage_DeInitialise();
    glfwTerminate();
    std::cout << argv[0] << " gracefully exits after " << update_count << " window updates." << std::endl;
    return 0; // Can be safely omitted, but the application will still return 0.
}

// end of warhol.cpp
